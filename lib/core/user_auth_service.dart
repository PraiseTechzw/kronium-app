import 'package:get/get.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:kronium/core/user_controller.dart';
import 'package:kronium/core/supabase_service.dart';
import 'package:kronium/models/user_model.dart' as models;

/// User authentication service using Supabase Auth
class UserAuthService {
  static final UserAuthService instance = UserAuthService._();
  UserAuthService._();

  final Rx<models.User?> userProfile = Rx<models.User?>(null);
  final RxBool isUserLoggedIn = false.obs;
  final RxBool isInitialized = false.obs;

  SupabaseClient get _client => Supabase.instance.client;
  SupabaseService get _supabaseService => SupabaseService.instance;

  models.User? get currentUserProfile => userProfile.value;

  Future<void> initialize() async {
    try {
      // Check for existing session
      final session = _client.auth.currentSession;
      if (session != null) {
        await _loadUserProfile(session.user.id);
      }
      
      // Listen to auth state changes
      _client.auth.onAuthStateChange.listen((data) async {
        final AuthChangeEvent event = data.event;
        final Session? session = data.session;
        
        if (event == AuthChangeEvent.signedIn && session != null) {
          await _loadUserProfile(session.user.id);
        } else if (event == AuthChangeEvent.signedOut) {
          userProfile.value = null;
          isUserLoggedIn.value = false;
          final userController = Get.find<UserController>();
          userController.logout();
        }
      });
      
      isInitialized.value = true;
    } catch (e) {
      print('Error initializing UserAuthService: $e');
      isInitialized.value = true; // Still mark as initialized
    }
  }

  Future<void> _loadUserProfile(String userId) async {
    try {
      final user = await _supabaseService.getUserById(userId);
      if (user != null) {
        userProfile.value = user;
        isUserLoggedIn.value = true;
        
        // Sync with UserController
        final userController = Get.find<UserController>();
        userController.setUserProfile(user);
        userController.setRole('customer');
      } else {
        // User doesn't exist in users table, create profile
        // Note: simpleId will be auto-generated by database trigger
        final supabaseUser = _client.auth.currentUser;
        if (supabaseUser != null) {
          try {
            final newUser = models.User(
              id: supabaseUser.id,
              simpleId: null, // Will be auto-generated by database (format: AAA00001)
              name: supabaseUser.userMetadata?['name'] ?? supabaseUser.email?.split('@').first ?? 'User',
              email: supabaseUser.email ?? '',
              phone: supabaseUser.userMetadata?['phone'] ?? '',
              createdAt: DateTime.now(),
              updatedAt: DateTime.now(),
            );
            
            await _supabaseService.addUser(newUser);
            
            // Reload the user to get the auto-generated simpleId
            final createdUser = await _supabaseService.getUserById(userId);
            if (createdUser != null) {
              userProfile.value = createdUser;
              isUserLoggedIn.value = true;
              
              final userController = Get.find<UserController>();
              userController.setUserProfile(createdUser);
              userController.setRole('customer');
            }
          } catch (e) {
            print('Error creating user profile: $e');
            // Even if profile creation fails, set basic auth state
            isUserLoggedIn.value = true;
          }
        }
      }
    } catch (e) {
      print('Error loading user profile: $e');
      // Don't throw, just log the error
    }
  }

  Future<Map<String, dynamic>> loginUser(String email, String password) async {
    try {
      final response = await _client.auth.signInWithPassword(
        email: email.trim(),
        password: password,
      );
      
      if (response.user != null) {
        await _loadUserProfile(response.user!.id);
        return {
          'success': true,
          'message': 'Login successful',
          'user': response.user,
        };
      } else {
        return {
          'success': false,
          'message': 'Login failed: No user returned',
        };
      }
    } on AuthException catch (e) {
      return {
        'success': false,
        'message': e.message,
      };
    } catch (e) {
      return {
        'success': false,
        'message': 'Login failed: ${e.toString()}',
      };
    }
  }

  Future<Map<String, dynamic>> registerUser(
    String name,
    String email,
    String phone,
    String password,
  ) async {
    try {
      final response = await _client.auth.signUp(
        email: email.trim(),
        password: password,
        data: {
          'name': name,
          'phone': phone,
        },
      );

      if (response.user != null) {
        // Create user profile in users table
        // Note: simpleId will be auto-generated by database trigger
        final newUser = models.User(
          id: response.user!.id,
          simpleId: null, // Will be auto-generated by database (format: AAA00001)
          name: name,
          email: email.trim(),
          phone: phone,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        try {
          await _supabaseService.addUser(newUser);
          await _loadUserProfile(response.user!.id);
          
          return {
            'success': true,
            'message': 'Registration successful',
            'user': response.user,
          };
        } catch (e) {
          // If profile creation fails, still return success but log error
          print('Error creating user profile: $e');
          return {
            'success': true,
            'message': 'Registration successful, but profile creation failed. Please try logging in.',
            'user': response.user,
          };
        }
      } else {
        return {
          'success': false,
          'message': 'Registration failed: No user returned',
        };
      }
    } on AuthException catch (e) {
      return {
        'success': false,
        'message': e.message,
      };
    } catch (e) {
      return {
        'success': false,
        'message': 'Registration failed: ${e.toString()}',
      };
    }
  }

  Future<void> updateUserProfile(Map<String, dynamic> data) async {
    try {
      final currentUser = _client.auth.currentUser;
      if (currentUser == null || userProfile.value == null) {
        throw Exception('No user logged in');
      }

      // Update in users table
      // Note: updatedAt is automatically handled by database trigger
      await _supabaseService.updateUser(currentUser.id, data);

      // Update metadata in Supabase Auth
      if (data.containsKey('name') || data.containsKey('phone')) {
        await _client.auth.updateUser(
          UserAttributes(
            data: {
              if (data.containsKey('name')) 'name': data['name'],
              if (data.containsKey('phone')) 'phone': data['phone'],
            },
          ),
        );
      }

      // Reload user profile
      await _loadUserProfile(currentUser.id);
    } catch (e) {
      print('Error updating user profile: $e');
      rethrow;
    }
  }

  Future<bool> changePassword(String newPassword) async {
    try {
      final currentUser = _client.auth.currentUser;
      if (currentUser == null) {
        return false;
      }

      await _client.auth.updateUser(
        UserAttributes(password: newPassword),
      );

      return true;
    } catch (e) {
      print('Error changing password: $e');
      return false;
    }
  }

  Future<void> logout() async {
    try {
      await _client.auth.signOut();
      userProfile.value = null;
      isUserLoggedIn.value = false;
      
      final userController = Get.find<UserController>();
      userController.logout();
    } catch (e) {
      print('Error during logout: $e');
      // Still clear local state even if logout fails
      userProfile.value = null;
      isUserLoggedIn.value = false;
      final userController = Get.find<UserController>();
      userController.logout();
    }
  }

  Future<void> validateAndRefreshSession() async {
    try {
      final session = _client.auth.currentSession;
      if (session != null) {
        // Session exists, refresh it
        await _client.auth.refreshSession();
        await _loadUserProfile(session.user.id);
      } else {
        // No session, clear state
        userProfile.value = null;
        isUserLoggedIn.value = false;
        final userController = Get.find<UserController>();
        userController.logout();
      }
    } catch (e) {
      print('Error validating session: $e');
      // Clear state on error
      userProfile.value = null;
      isUserLoggedIn.value = false;
      final userController = Get.find<UserController>();
      userController.logout();
    }
  }

  Future<void> forceGenerateSimpleId() async {
    try {
      final currentUser = _client.auth.currentUser;
      if (currentUser == null || userProfile.value == null) {
        return;
      }

      // If user doesn't have simpleId, the database trigger will generate it
      // on the next update or we can trigger it by updating the user record
      if (userProfile.value!.simpleId == null || userProfile.value!.simpleId!.isEmpty) {
        // Trigger ID generation by updating user (database trigger will handle it)
        // Update a harmless field to trigger the update (database trigger will generate simpleId and update updatedAt)
        await _supabaseService.updateUser(currentUser.id, {
          'name': userProfile.value!.name, // Update with same value to trigger trigger
        });
        await _loadUserProfile(currentUser.id);
      }
    } catch (e) {
      print('Error generating simple ID: $e');
    }
  }

  Future<Map<String, dynamic>> resetPassword(String email) async {
    try {
      await _client.auth.resetPasswordForEmail(email.trim());
      return {
        'success': true,
        'message': 'Password reset email sent. Please check your inbox.',
      };
    } on AuthException catch (e) {
      return {
        'success': false,
        'message': e.message,
      };
    } catch (e) {
      return {
        'success': false,
        'message': 'Failed to send password reset email: ${e.toString()}',
      };
    }
  }
}
